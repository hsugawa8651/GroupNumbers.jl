var documenterSearchIndex = {"docs":
[{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Modules = [GroupNumbers]","category":"page"},{"location":"reference/#GroupNumbers.groupby2-Union{Tuple{I}, Tuple{F2}, Tuple{F1}} where {F1<:Union{Function, Type}, F2<:Union{Function, Type}, I}","page":"API Reference","title":"GroupNumbers.groupby2","text":"groupby2(xs; keyfunc=identity, compare=isequal)\n\nAn iterator that yields a group of elements xg from the iterator xs, where the key is computed by applying keyfunc to each element of xs. Compare adjacent keys by compare function, then, delivers the vector xg of the grouped elements.\n\nExamples\n\nExample 1: Group characters\n\njulia> collect(groupby2(\"A\"))\n1-element Vector{Vector{Char}}:\n ['A']\n\njulia> collect(groupby2(\"AAAABBBCCD\"))\n4-element Vector{Vector{Char}}:\n ['A', 'A', 'A', 'A']\n ['B', 'B', 'B']\n ['C', 'C']\n ['D']\n\nExample 2: Group integer numbers\n\njulia> collect(groupby2([10,20,20,30]))\n3-element Vector{Vector{Int64}}:\n [10]\n [20, 20]\n [30]\n\nExample 3: Group floating point numbers\n\njulia> collect(groupby2(\n        [1+2e-10, -(1+2e-9), 1+2e-8, -(1+2e-7)];\n        compare=isapprox, keyfunc=abs))\n3-element Vector{Vector{Float64}}:\n [1.0000000002, -1.000000002]\n [1.00000002]\n [-1.0000002]\n\nExample 4: Group noisy vectors with their norm\n\njulia> using LinearAlgebra\njulia> vs1=[ begin \n            v=(i1+(rand()-0.5)*1e-8,i2+(rand()-0.5)*1e-8);\n            (v=v,n=norm(v))\n        end for i1 in -2:2, i2 in -2:2] |> vec; \njulia> vs2=sort(vs1; by=x->x.n); \njulia> [ length(g) for g in groupby2(vs2; keyfunc=x->x.n, compare=isapprox) ]\n6-element Vector{Int64}:\n 1\n 4\n 4\n 4\n 8\n 4\n\n\n\n\n\n","category":"method"},{"location":"reference/#GroupNumbers.groupby2_dict-Union{Tuple{I}, Tuple{F2}, Tuple{F1}} where {F1<:Union{Function, Type}, F2<:Union{Function, Type}, I}","page":"API Reference","title":"GroupNumbers.groupby2_dict","text":"groupby2_dict(xs; keyfunc=identity, compare=isequal)\n\nAn iterator that yields a key-and-group pair (k,xg) from the iterator xs, where the key k is computed by applying keyfunc to each element of xs. Compare adjacent keys by compare function, then, delivers the key k and the vector xg of the grouped elements .\n\nExamples\n\nExample 1: Group characters\n\njulia> collect(groupby2_dict(\"A\"))\n1-element Vector{Tuple{Any, Vector{Char}}}:\n ('A', ['A'])\n\njulia> collect(groupby2_dict(\"AAAABBBCCD\"))\n4-element Vector{Tuple{Any, Vector{Char}}}:\n ('A', ['A', 'A', 'A', 'A'])\n ('B', ['B', 'B', 'B'])\n ('C', ['C', 'C'])\n ('D', ['D'])\n\nExample 2: Group integer numbers\n\njulia> collect(groupby2_dict([10,20,20,30]))\n3-element Vector{Tuple{Any, Vector{Int64}}}:\n (10, [10])\n (20, [20, 20])\n (30, [30])\n\nExample 3: Group floating point numbers\n\njulia> collect(groupby2_dict(\n        [1+2e-10, -(1+2e-9), 1+2e-8, -(1+2e-7)];\n        compare=isapprox, keyfunc=abs))\n3-element Vector{Tuple{Any, Vector{Float64}}}:\n (1.0000000002, [1.0000000002, -1.000000002])\n (1.00000002, [1.00000002])\n (1.0000002, [-1.0000002])\n\n\nExample 4: Group noisy vectors with their norm\n\njulia> using LinearAlgebra\njulia> vs1=[ begin \n            v=(i1+(rand()-0.5)*1e-8,i2+(rand()-0.5)*1e-8);\n            (v=v,n=norm(v))\n        end for i1 in -2:2, i2 in -2:2] |> vec;\njulia> vs2=sort(vs1; by=x->x.n);\njulia> [ (k,length(g)) for (k,g) in groupby2_dict(vs2; keyfunc=x->x.n, compare=isapprox) ]\n6-element Vector{Tuple{Float64, Int64}}:\n (4.16311498666887e-11, 1)\n (0.999999999984808, 4)\n (1.4142135623388605, 4)\n (1.9999999999726468, 4)\n (2.236067977467306, 8)\n (2.828427124726703, 4)\n\n\n\n\n\n","category":"method"},{"location":"reference/#GroupNumbers.groupby2_dict_indices-Union{Tuple{I}, Tuple{F2}, Tuple{F1}} where {F1<:Union{Function, Type}, F2<:Union{Function, Type}, I}","page":"API Reference","title":"GroupNumbers.groupby2_dict_indices","text":"groupby2_dict_indices(xs; keyfunc=identity, compare=isequal)\n\nAn iterator that yields a key-and-group pair (k,ig) from the iterator xs, where the key k is computed by applying keyfunc to each element of xs. Compare adjacent keys by compare function, then, delivers the key k and the vector ig of the grouped indices.\n\nExamples\n\nExample 1: Group characters\n\njulia> collect(groupby2_dict_indices(\"A\"))\n1-element Vector{Tuple{Any, Vector{Int64}}}:\n ('A', [1])\n\njulia> collect(groupby2_dict_indices(\"AAAABBBCCD\"))\n4-element Vector{Tuple{Any, Vector{Int64}}}:\n ('A', [1, 2, 3, 4])\n ('B', [5, 6, 7])\n ('C', [8, 9])\n ('D', [10])\n\nExample 2: Group integer numbers\n\njulia> collect(groupby2_dict_indices([10,20,20,30]))\n3-element Vector{Tuple{Any, Vector{Int64}}}:\n (10, [1])\n (20, [2, 3])\n (30, [4])\n\nExample 3: Group floating point numbers\n\njulia> collect(groupby2_dict_indices(\n        [1+2e-10, -(1+2e-9), 1+2e-8, -(1+2e-7)];\n        compare=isapprox, keyfunc=abs))\n3-element Vector{Tuple{Any, Vector{Int64}}}:\n (1.0000000002, [1, 2])\n (1.00000002, [3])\n (1.0000002, [4])\n\nExample 4: Group noisy vectors with their norm\n\njulia> using LinearAlgebra\njulia> vs1=[ begin \n            v=(i1+(rand()-0.5)*1e-8,i2+(rand()-0.5)*1e-8);\n            (v=v,n=norm(v))\n        end for i1 in -2:2, i2 in -2:2] |> vec;\njulia> vs2=sort(vs1; by=x->x.n);\njulia> collect(groupby2_dict_indices(vs2; keyfunc=x->x.n, compare=isapprox))\n6-element Vector{Tuple{Any, Vector{Int64}}}:\n (3.444788576260325e-11, [1])\n (0.9999999999517916, [2, 3, 4, 5])\n (1.4142135623328898, [6, 7, 8, 9])\n (1.9999999999690443, [10, 11, 12, 13])\n (2.236067977456823, [14, 15, 16, 17, 18, 19, 20, 21])\n (2.828427124691792, [22, 23, 24, 25])\n\n\n\n\n\n","category":"method"},{"location":"reference/#GroupNumbers.groupby2_indices-Union{Tuple{I}, Tuple{F2}, Tuple{F1}} where {F1<:Union{Function, Type}, F2<:Union{Function, Type}, I}","page":"API Reference","title":"GroupNumbers.groupby2_indices","text":"groupby2_indices(xs; keyfunc=identity, compare=isequal)\n\nAn iterator that yields a group of indices ig from the iterator xs, where the key is computed by applying keyfunc to each element of xs. Compare adjacent keys by compare function, then, delivers the vector ig of the grouped indices.\n\nExamples\n\nExample 1: Group characters\n\njulia> collect(groupby2_indices(\"A\"))\n1-element Vector{Vector{Int64}}:\n [1]\n\njulia> collect(groupby2_indices(\"AAAABBBCCD\"))\n4-element Vector{Vector{Int64}}:\n [1, 2, 3, 4]\n [5, 6, 7]\n [8, 9]\n [10]\n\nExample 2: Group integer numbers\n\njulia> collect(groupby2_indices([10,20,20,30]))\n3-element Vector{Vector{Int64}}:\n [1]\n [2, 3]\n [4]\n\nExample 3: Group floating point numbers\n\njulia> collect(groupby2_indices(\n        [1+2e-10, -(1+2e-9), 1+2e-8, -(1+2e-7)];\n        compare=isapprox, keyfunc=abs))\n3-element Vector{Vector{Int64}}:\n [1, 2]\n [3]\n [4]\n\nExample 4: Group noisy vectors with their norm\n\njulia> using LinearAlgebra\njulia> vs1=[ begin \n            v=(i1+(rand()-0.5)*1e-8,i2+(rand()-0.5)*1e-8);\n            (v=v,n=norm(v))\n        end for i1 in -2:2, i2 in -2:2] |> vec;\njulia> vs2=sort(vs1; by=x->x.n);\n\njulia> collect(groupby2_indices(vs2; keyfunc=x->x.n, compare=isapprox))\n6-element Vector{Vector{Int64}}:\n [1]\n [2, 3, 4, 5]\n [6, 7, 8, 9]\n [10, 11, 12, 13]\n [14, 15, 16, 17, 18, 19, 20, 21]\n [22, 23, 24, 25]\n\n\n\n\n\n","category":"method"},{"location":"reference/#GroupNumbers.groupby_numbers-Tuple{Any}","page":"API Reference","title":"GroupNumbers.groupby_numbers","text":"groupby_numbers(xs; keyfunc=identity, kwargs)\n\nAn iterator that yields a group of numbers xg from the iterator xs of presumably numbers, where the key is computed by applying keyfunc to each element of xs. Compare adjacent keys by isapprox function with supplied kwargs optional parameters,  then, delivers the vector xg of the grouped numbers.\n\nExamples\n\nExample 1: Group integer numbers\n\njulia> collect(groupby_numbers([10,20,20,30]))\n3-element Vector{Vector{Int64}}:\n [10]\n [20, 20]\n [30]\n\njulia> collect(groupby_numbers([10,20,-20,30]; keyfunc=abs))\n3-element Vector{Vector{Int64}}:\n [10]\n [20, -20]\n [30]\n\nExample 2: Group floating point numbers\n\njulia> collect(groupby_numbers([ 2e-5, 2e-4, 2e-3, 2e-2 ] .+ 1; rtol=1e-3))\n3-element Vector{Vector{Float64}}:\n [1.00002, 1.0002]\n [1.002]\n [1.02]\n\njulia> collect(groupby_numbers([ 1+2e-5, -(1+2e-4), 1+2e-3, -(1+2e-2) ]; keyfunc=abs, rtol=1e-3))\n3-element Vector{Vector{Float64}}:\n [1.00002, -1.0002]\n [1.002]\n [-1.02]\n\nExample 3: Group noisy vectors with their norm\n\njulia> using LinearAlgebra\n\njulia> vs1=[ begin \n            v=(i1+(rand()-0.5)*1e-8,i2+(rand()-0.5)*1e-8);\n            (v=v,n=norm(v))\n        end for i1 in -2:2, i2 in -2:2] |> vec;\njulia> vs2=sort(vs1; by=x->x.n);\njulia> map(length, groupby_numbers(vs2; keyfunc=x->x.n, rtol=1e-3))\n6-element Vector{Int64}:\n 1\n 4\n 4\n 4\n 8\n 4\n\n\n\n\n\n","category":"method"},{"location":"reference/#GroupNumbers.groupby_numbers_dict-Tuple{Any}","page":"API Reference","title":"GroupNumbers.groupby_numbers_dict","text":"groupby_numbers_dict(xs; keyfunc=identity, kwargs)\n\nAn iterator that yields a key-and-group pair (k,xg) from the iterator xs of presumably numbers, where the key k is computed by applying keyfunc to each element of xs. Compare adjacent keys by isapprox function with supplied kwargs optional parameters,  then, delivers the key k and the vector xg of grouped elements.\n\nExamples\n\nExample 1: Group integer numbers\n\njulia> collect(groupby_numbers_dict([10,20,20,30]))\n3-element Vector{Tuple{Any, Vector{Int64}}}:\n (10, [10])\n (20, [20, 20])\n (30, [30])\n\njulia> collect(groupby_numbers_dict([10,20,-20,30]; keyfunc=abs))\n3-element Vector{Tuple{Any, Vector{Int64}}}:\n (10, [10])\n (20, [20, -20])\n (30, [30])\n\nExample 2: Group floating point numbers\n\njulia> collect(groupby_numbers_dict([ 2e-5, 2e-4, 2e-3, 2e-2 ] .+ 1; rtol=1e-3))\n3-element Vector{Tuple{Any, Vector{Float64}}}:\n (1.00002, [1.00002, 1.0002])\n (1.002, [1.002])\n (1.02, [1.02])\n\njulia> collect(groupby_numbers_dict([ 1+2e-5, -(1+2e-4), 1+2e-3, -(1+2e-2) ];\n        keyfunc=abs, rtol=1e-3))\n3-element Vector{Tuple{Any, Vector{Float64}}}:\n (1.00002, [1.00002, -1.0002])\n (1.002, [1.002])\n (1.02, [-1.02])\n\nExample 3: Group noisy vectors with their norm\n\njulia> using LinearAlgebra\njulia> vs1=[ begin \n            v=(i1+(rand()-0.5)*1e-8,i2+(rand()-0.5)*1e-8);\n            (v=v,n=norm(v))\n        end for i1 in -2:2, i2 in -2:2] |> vec;\njulia> vs2=sort(vs1; by=x->x.n);\njulia> [ (k,length(xg)) for (k,xg) in \n            groupby_numbers_dict(vs2; keyfunc=x->x.n, rtol=1e-3) ]\n    end\n6-element Vector{Tuple{Float64, Int64}}:\n (3.2527338422665044e-11, 1)\n (0.999999999995845, 4)\n (1.4142135623542986, 4)\n (2.000000000002051, 4)\n (2.236067977452884, 8)\n (2.8284271246921855, 4)\n\n\n\n\n\n","category":"method"},{"location":"reference/#GroupNumbers.groupby_numbers_dict_indices-Tuple{Any}","page":"API Reference","title":"GroupNumbers.groupby_numbers_dict_indices","text":"groupby_numbers_dict(xs; keyfunc=identity, kwargs)\n\nAn iterator that yields a key-and-group pair (k,ig) from the iterator xs of presumably numbers, where the key k is computed by applying keyfunc to each element of xs. Compare adjacent keys by isapprox function with supplied kwargs optional parameters,  then, delivers the key k and the vector ig of the grouped indices.\n\nExamples\n\nExample 1: Group integer numbers\n\njulia> collect(groupby_numbers_dict([10,20,20,30]))\n3-element Vector{Tuple{Any, Vector{Int64}}}:\n (10, [10])\n (20, [20, 20])\n (30, [30])\n\njulia> collect(groupby_numbers_dict([10,20,-20,30]; keyfunc=abs))\n3-element Vector{Tuple{Any, Vector{Int64}}}:\n (10, [10])\n (20, [20, -20])\n (30, [30])\n\nExample 2: Group floating point numbers\n\njulia> collect(groupby_numbers_dict([ 2e-5, 2e-4, 2e-3, 2e-2 ] .+ 1; rtol=1e-3))\n3-element Vector{Tuple{Any, Vector{Float64}}}:\n (1.00002, [1.00002, 1.0002])\n (1.002, [1.002])\n (1.02, [1.02])\n\njulia> collect(groupby_numbers_dict(\n            [ 1+2e-5, -(1+2e-4), 1+2e-3, -(1+2e-2) ];  \n            keyfunc=abs, rtol=1e-3))\n3-element Vector{Tuple{Any, Vector{Float64}}}:\n (1.00002, [1.00002, -1.0002])\n (1.002, [1.002])\n (1.02, [-1.02])\n\nExample 3: Group noisy vectors with their norm\n\njulia> using LinearAlgebra\njulia> vs1=[ begin \n            v=(i1+(rand()-0.5)*1e-8,i2+(rand()-0.5)*1e-8);\n            (v=v,n=norm(v))\n        end for i1 in -2:2, i2 in -2:2] |> vec;\njulia> vs2=sort(vs1; by=x->x.n);\njulia> [ (k,length(xg)) for (k,xg) in \n            groupby_numbers_dict(vs2; keyfunc=x->x.n, rtol=1e-3) ]\n6-element Vector{Tuple{Float64, Int64}}:\n (4.641593797139748e-11, 1)\n (0.9999999999691114, 4)\n (1.4142135623658871, 4)\n (1.99999999995389, 4)\n (2.236067977448624, 8)\n (2.828427124697913, 4)\n\n\n\n\n\n","category":"method"},{"location":"reference/#GroupNumbers.groupby_numbers_indices-Tuple{Any}","page":"API Reference","title":"GroupNumbers.groupby_numbers_indices","text":"groupby_numbers_indices(xs; keyfunc=identity, kwargs)\n\nAn iterator that yields a group of indices ig from the iterator xs of presumably numbers, where the key is computed by applying keyfunc to each element of xs. Compare adjacent keys by isapprox function with supplied kwargs optional parameters,  then, delivers the vector ig of the grouped indices.\n\nExamples\n\nExample 1: Group integer numbers\n\njulia> collect(groupby_numbers_indices([10,20,20,30]))\n3-element Vector{Vector{Int64}}:\n [1]\n [2, 3]\n [4]\n\njulia> collect(groupby_numbers_indices([10,20,-20,30]; keyfunc=abs))\n3-element Vector{Vector{Int64}}:\n [1]\n [2, 3]\n [4]\n\nExample 2: Group floating point numbers\n\njulia> collect(groupby_numbers_indices([ 2e-5, 2e-4, 2e-3, 2e-2 ] .+ 1; rtol=1e-3))\n3-element Vector{Vector{Int64}}:\n [1, 2]\n [3]\n [4]\n\njulia> collect(groupby_numbers_indices([ 1+2e-5, -(1+2e-4), 1+2e-3, -(1+2e-2) ]; \n        keyfunc=abs, rtol=1e-3))\n3-element Vector{Vector{Int64}}:\n [1, 2]\n [3]\n [4]\n\nExample 3: Group noisy vectors with their norm\n\n julia> using LinearAlgebra\n\njulia> vs1=[ begin \n            v=(i1+(rand()-0.5)*1e-8,i2+(rand()-0.5)*1e-8);\n            (v=v,n=norm(v))\n        end for i1 in -2:2, i2 in -2:2] |> vec;\njulia> vs2=sort(vs1; by=x->x.n);\njulia> collect(groupby_numbers_indices(vs2; keyfunc=x->x.n, rtol=1e-3) )\n6-element Vector{Vector{Int64}}:\n [1]\n [2, 3, 4, 5]\n [6, 7, 8, 9]\n [10, 11, 12, 13]\n [14, 15, 16, 17, 18, 19, 20, 21]\n [22, 23, 24, 25]\n\n\n\n\n\n","category":"method"},{"location":"#GroupNumbers","page":"Home","title":"GroupNumbers","text":"","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install this package with Pkg.add(\"GroupNumbers\")","category":"page"},{"location":"#Description","page":"Home","title":"Description","text":"","category":"section"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"#Iterators-delivering-only-grouped-elements-or-indices","page":"Home","title":"Iterators delivering only grouped elements or indices","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GroupNumbers.groupby2\nGroupNumbers.groupby2_indices\nGroupNumbers.groupby_numbers\nGroupNumbers.groupby_numbers_indices","category":"page"},{"location":"#GroupNumbers.groupby2","page":"Home","title":"GroupNumbers.groupby2","text":"groupby2(xs; keyfunc=identity, compare=isequal)\n\nAn iterator that yields a group of elements xg from the iterator xs, where the key is computed by applying keyfunc to each element of xs. Compare adjacent keys by compare function, then, delivers the vector xg of the grouped elements.\n\nExamples\n\nExample 1: Group characters\n\njulia> collect(groupby2(\"A\"))\n1-element Vector{Vector{Char}}:\n ['A']\n\njulia> collect(groupby2(\"AAAABBBCCD\"))\n4-element Vector{Vector{Char}}:\n ['A', 'A', 'A', 'A']\n ['B', 'B', 'B']\n ['C', 'C']\n ['D']\n\nExample 2: Group integer numbers\n\njulia> collect(groupby2([10,20,20,30]))\n3-element Vector{Vector{Int64}}:\n [10]\n [20, 20]\n [30]\n\nExample 3: Group floating point numbers\n\njulia> collect(groupby2(\n        [1+2e-10, -(1+2e-9), 1+2e-8, -(1+2e-7)];\n        compare=isapprox, keyfunc=abs))\n3-element Vector{Vector{Float64}}:\n [1.0000000002, -1.000000002]\n [1.00000002]\n [-1.0000002]\n\nExample 4: Group noisy vectors with their norm\n\njulia> using LinearAlgebra\njulia> vs1=[ begin \n            v=(i1+(rand()-0.5)*1e-8,i2+(rand()-0.5)*1e-8);\n            (v=v,n=norm(v))\n        end for i1 in -2:2, i2 in -2:2] |> vec; \njulia> vs2=sort(vs1; by=x->x.n); \njulia> [ length(g) for g in groupby2(vs2; keyfunc=x->x.n, compare=isapprox) ]\n6-element Vector{Int64}:\n 1\n 4\n 4\n 4\n 8\n 4\n\n\n\n\n\n","category":"function"},{"location":"#GroupNumbers.groupby2_indices","page":"Home","title":"GroupNumbers.groupby2_indices","text":"groupby2_indices(xs; keyfunc=identity, compare=isequal)\n\nAn iterator that yields a group of indices ig from the iterator xs, where the key is computed by applying keyfunc to each element of xs. Compare adjacent keys by compare function, then, delivers the vector ig of the grouped indices.\n\nExamples\n\nExample 1: Group characters\n\njulia> collect(groupby2_indices(\"A\"))\n1-element Vector{Vector{Int64}}:\n [1]\n\njulia> collect(groupby2_indices(\"AAAABBBCCD\"))\n4-element Vector{Vector{Int64}}:\n [1, 2, 3, 4]\n [5, 6, 7]\n [8, 9]\n [10]\n\nExample 2: Group integer numbers\n\njulia> collect(groupby2_indices([10,20,20,30]))\n3-element Vector{Vector{Int64}}:\n [1]\n [2, 3]\n [4]\n\nExample 3: Group floating point numbers\n\njulia> collect(groupby2_indices(\n        [1+2e-10, -(1+2e-9), 1+2e-8, -(1+2e-7)];\n        compare=isapprox, keyfunc=abs))\n3-element Vector{Vector{Int64}}:\n [1, 2]\n [3]\n [4]\n\nExample 4: Group noisy vectors with their norm\n\njulia> using LinearAlgebra\njulia> vs1=[ begin \n            v=(i1+(rand()-0.5)*1e-8,i2+(rand()-0.5)*1e-8);\n            (v=v,n=norm(v))\n        end for i1 in -2:2, i2 in -2:2] |> vec;\njulia> vs2=sort(vs1; by=x->x.n);\n\njulia> collect(groupby2_indices(vs2; keyfunc=x->x.n, compare=isapprox))\n6-element Vector{Vector{Int64}}:\n [1]\n [2, 3, 4, 5]\n [6, 7, 8, 9]\n [10, 11, 12, 13]\n [14, 15, 16, 17, 18, 19, 20, 21]\n [22, 23, 24, 25]\n\n\n\n\n\n","category":"function"},{"location":"#GroupNumbers.groupby_numbers","page":"Home","title":"GroupNumbers.groupby_numbers","text":"groupby_numbers(xs; keyfunc=identity, kwargs)\n\nAn iterator that yields a group of numbers xg from the iterator xs of presumably numbers, where the key is computed by applying keyfunc to each element of xs. Compare adjacent keys by isapprox function with supplied kwargs optional parameters,  then, delivers the vector xg of the grouped numbers.\n\nExamples\n\nExample 1: Group integer numbers\n\njulia> collect(groupby_numbers([10,20,20,30]))\n3-element Vector{Vector{Int64}}:\n [10]\n [20, 20]\n [30]\n\njulia> collect(groupby_numbers([10,20,-20,30]; keyfunc=abs))\n3-element Vector{Vector{Int64}}:\n [10]\n [20, -20]\n [30]\n\nExample 2: Group floating point numbers\n\njulia> collect(groupby_numbers([ 2e-5, 2e-4, 2e-3, 2e-2 ] .+ 1; rtol=1e-3))\n3-element Vector{Vector{Float64}}:\n [1.00002, 1.0002]\n [1.002]\n [1.02]\n\njulia> collect(groupby_numbers([ 1+2e-5, -(1+2e-4), 1+2e-3, -(1+2e-2) ]; keyfunc=abs, rtol=1e-3))\n3-element Vector{Vector{Float64}}:\n [1.00002, -1.0002]\n [1.002]\n [-1.02]\n\nExample 3: Group noisy vectors with their norm\n\njulia> using LinearAlgebra\n\njulia> vs1=[ begin \n            v=(i1+(rand()-0.5)*1e-8,i2+(rand()-0.5)*1e-8);\n            (v=v,n=norm(v))\n        end for i1 in -2:2, i2 in -2:2] |> vec;\njulia> vs2=sort(vs1; by=x->x.n);\njulia> map(length, groupby_numbers(vs2; keyfunc=x->x.n, rtol=1e-3))\n6-element Vector{Int64}:\n 1\n 4\n 4\n 4\n 8\n 4\n\n\n\n\n\n","category":"function"},{"location":"#GroupNumbers.groupby_numbers_indices","page":"Home","title":"GroupNumbers.groupby_numbers_indices","text":"groupby_numbers_indices(xs; keyfunc=identity, kwargs)\n\nAn iterator that yields a group of indices ig from the iterator xs of presumably numbers, where the key is computed by applying keyfunc to each element of xs. Compare adjacent keys by isapprox function with supplied kwargs optional parameters,  then, delivers the vector ig of the grouped indices.\n\nExamples\n\nExample 1: Group integer numbers\n\njulia> collect(groupby_numbers_indices([10,20,20,30]))\n3-element Vector{Vector{Int64}}:\n [1]\n [2, 3]\n [4]\n\njulia> collect(groupby_numbers_indices([10,20,-20,30]; keyfunc=abs))\n3-element Vector{Vector{Int64}}:\n [1]\n [2, 3]\n [4]\n\nExample 2: Group floating point numbers\n\njulia> collect(groupby_numbers_indices([ 2e-5, 2e-4, 2e-3, 2e-2 ] .+ 1; rtol=1e-3))\n3-element Vector{Vector{Int64}}:\n [1, 2]\n [3]\n [4]\n\njulia> collect(groupby_numbers_indices([ 1+2e-5, -(1+2e-4), 1+2e-3, -(1+2e-2) ]; \n        keyfunc=abs, rtol=1e-3))\n3-element Vector{Vector{Int64}}:\n [1, 2]\n [3]\n [4]\n\nExample 3: Group noisy vectors with their norm\n\n julia> using LinearAlgebra\n\njulia> vs1=[ begin \n            v=(i1+(rand()-0.5)*1e-8,i2+(rand()-0.5)*1e-8);\n            (v=v,n=norm(v))\n        end for i1 in -2:2, i2 in -2:2] |> vec;\njulia> vs2=sort(vs1; by=x->x.n);\njulia> collect(groupby_numbers_indices(vs2; keyfunc=x->x.n, rtol=1e-3) )\n6-element Vector{Vector{Int64}}:\n [1]\n [2, 3, 4, 5]\n [6, 7, 8, 9]\n [10, 11, 12, 13]\n [14, 15, 16, 17, 18, 19, 20, 21]\n [22, 23, 24, 25]\n\n\n\n\n\n","category":"function"},{"location":"#Iterators-delivering-keys-and-grouped-elements-or-indices","page":"Home","title":"Iterators delivering keys and grouped elements or indices","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GroupNumbers.groupby2_dict\nGroupNumbers.groupby2_dict_indices\nGroupNumbers.groupby_numbers_dict\nGroupNumbers.groupby_numbers_dict_indices","category":"page"},{"location":"#GroupNumbers.groupby2_dict","page":"Home","title":"GroupNumbers.groupby2_dict","text":"groupby2_dict(xs; keyfunc=identity, compare=isequal)\n\nAn iterator that yields a key-and-group pair (k,xg) from the iterator xs, where the key k is computed by applying keyfunc to each element of xs. Compare adjacent keys by compare function, then, delivers the key k and the vector xg of the grouped elements .\n\nExamples\n\nExample 1: Group characters\n\njulia> collect(groupby2_dict(\"A\"))\n1-element Vector{Tuple{Any, Vector{Char}}}:\n ('A', ['A'])\n\njulia> collect(groupby2_dict(\"AAAABBBCCD\"))\n4-element Vector{Tuple{Any, Vector{Char}}}:\n ('A', ['A', 'A', 'A', 'A'])\n ('B', ['B', 'B', 'B'])\n ('C', ['C', 'C'])\n ('D', ['D'])\n\nExample 2: Group integer numbers\n\njulia> collect(groupby2_dict([10,20,20,30]))\n3-element Vector{Tuple{Any, Vector{Int64}}}:\n (10, [10])\n (20, [20, 20])\n (30, [30])\n\nExample 3: Group floating point numbers\n\njulia> collect(groupby2_dict(\n        [1+2e-10, -(1+2e-9), 1+2e-8, -(1+2e-7)];\n        compare=isapprox, keyfunc=abs))\n3-element Vector{Tuple{Any, Vector{Float64}}}:\n (1.0000000002, [1.0000000002, -1.000000002])\n (1.00000002, [1.00000002])\n (1.0000002, [-1.0000002])\n\n\nExample 4: Group noisy vectors with their norm\n\njulia> using LinearAlgebra\njulia> vs1=[ begin \n            v=(i1+(rand()-0.5)*1e-8,i2+(rand()-0.5)*1e-8);\n            (v=v,n=norm(v))\n        end for i1 in -2:2, i2 in -2:2] |> vec;\njulia> vs2=sort(vs1; by=x->x.n);\njulia> [ (k,length(g)) for (k,g) in groupby2_dict(vs2; keyfunc=x->x.n, compare=isapprox) ]\n6-element Vector{Tuple{Float64, Int64}}:\n (4.16311498666887e-11, 1)\n (0.999999999984808, 4)\n (1.4142135623388605, 4)\n (1.9999999999726468, 4)\n (2.236067977467306, 8)\n (2.828427124726703, 4)\n\n\n\n\n\n","category":"function"},{"location":"#GroupNumbers.groupby2_dict_indices","page":"Home","title":"GroupNumbers.groupby2_dict_indices","text":"groupby2_dict_indices(xs; keyfunc=identity, compare=isequal)\n\nAn iterator that yields a key-and-group pair (k,ig) from the iterator xs, where the key k is computed by applying keyfunc to each element of xs. Compare adjacent keys by compare function, then, delivers the key k and the vector ig of the grouped indices.\n\nExamples\n\nExample 1: Group characters\n\njulia> collect(groupby2_dict_indices(\"A\"))\n1-element Vector{Tuple{Any, Vector{Int64}}}:\n ('A', [1])\n\njulia> collect(groupby2_dict_indices(\"AAAABBBCCD\"))\n4-element Vector{Tuple{Any, Vector{Int64}}}:\n ('A', [1, 2, 3, 4])\n ('B', [5, 6, 7])\n ('C', [8, 9])\n ('D', [10])\n\nExample 2: Group integer numbers\n\njulia> collect(groupby2_dict_indices([10,20,20,30]))\n3-element Vector{Tuple{Any, Vector{Int64}}}:\n (10, [1])\n (20, [2, 3])\n (30, [4])\n\nExample 3: Group floating point numbers\n\njulia> collect(groupby2_dict_indices(\n        [1+2e-10, -(1+2e-9), 1+2e-8, -(1+2e-7)];\n        compare=isapprox, keyfunc=abs))\n3-element Vector{Tuple{Any, Vector{Int64}}}:\n (1.0000000002, [1, 2])\n (1.00000002, [3])\n (1.0000002, [4])\n\nExample 4: Group noisy vectors with their norm\n\njulia> using LinearAlgebra\njulia> vs1=[ begin \n            v=(i1+(rand()-0.5)*1e-8,i2+(rand()-0.5)*1e-8);\n            (v=v,n=norm(v))\n        end for i1 in -2:2, i2 in -2:2] |> vec;\njulia> vs2=sort(vs1; by=x->x.n);\njulia> collect(groupby2_dict_indices(vs2; keyfunc=x->x.n, compare=isapprox))\n6-element Vector{Tuple{Any, Vector{Int64}}}:\n (3.444788576260325e-11, [1])\n (0.9999999999517916, [2, 3, 4, 5])\n (1.4142135623328898, [6, 7, 8, 9])\n (1.9999999999690443, [10, 11, 12, 13])\n (2.236067977456823, [14, 15, 16, 17, 18, 19, 20, 21])\n (2.828427124691792, [22, 23, 24, 25])\n\n\n\n\n\n","category":"function"},{"location":"#GroupNumbers.groupby_numbers_dict","page":"Home","title":"GroupNumbers.groupby_numbers_dict","text":"groupby_numbers_dict(xs; keyfunc=identity, kwargs)\n\nAn iterator that yields a key-and-group pair (k,xg) from the iterator xs of presumably numbers, where the key k is computed by applying keyfunc to each element of xs. Compare adjacent keys by isapprox function with supplied kwargs optional parameters,  then, delivers the key k and the vector xg of grouped elements.\n\nExamples\n\nExample 1: Group integer numbers\n\njulia> collect(groupby_numbers_dict([10,20,20,30]))\n3-element Vector{Tuple{Any, Vector{Int64}}}:\n (10, [10])\n (20, [20, 20])\n (30, [30])\n\njulia> collect(groupby_numbers_dict([10,20,-20,30]; keyfunc=abs))\n3-element Vector{Tuple{Any, Vector{Int64}}}:\n (10, [10])\n (20, [20, -20])\n (30, [30])\n\nExample 2: Group floating point numbers\n\njulia> collect(groupby_numbers_dict([ 2e-5, 2e-4, 2e-3, 2e-2 ] .+ 1; rtol=1e-3))\n3-element Vector{Tuple{Any, Vector{Float64}}}:\n (1.00002, [1.00002, 1.0002])\n (1.002, [1.002])\n (1.02, [1.02])\n\njulia> collect(groupby_numbers_dict([ 1+2e-5, -(1+2e-4), 1+2e-3, -(1+2e-2) ];\n        keyfunc=abs, rtol=1e-3))\n3-element Vector{Tuple{Any, Vector{Float64}}}:\n (1.00002, [1.00002, -1.0002])\n (1.002, [1.002])\n (1.02, [-1.02])\n\nExample 3: Group noisy vectors with their norm\n\njulia> using LinearAlgebra\njulia> vs1=[ begin \n            v=(i1+(rand()-0.5)*1e-8,i2+(rand()-0.5)*1e-8);\n            (v=v,n=norm(v))\n        end for i1 in -2:2, i2 in -2:2] |> vec;\njulia> vs2=sort(vs1; by=x->x.n);\njulia> [ (k,length(xg)) for (k,xg) in \n            groupby_numbers_dict(vs2; keyfunc=x->x.n, rtol=1e-3) ]\n    end\n6-element Vector{Tuple{Float64, Int64}}:\n (3.2527338422665044e-11, 1)\n (0.999999999995845, 4)\n (1.4142135623542986, 4)\n (2.000000000002051, 4)\n (2.236067977452884, 8)\n (2.8284271246921855, 4)\n\n\n\n\n\n","category":"function"},{"location":"#GroupNumbers.groupby_numbers_dict_indices","page":"Home","title":"GroupNumbers.groupby_numbers_dict_indices","text":"groupby_numbers_dict(xs; keyfunc=identity, kwargs)\n\nAn iterator that yields a key-and-group pair (k,ig) from the iterator xs of presumably numbers, where the key k is computed by applying keyfunc to each element of xs. Compare adjacent keys by isapprox function with supplied kwargs optional parameters,  then, delivers the key k and the vector ig of the grouped indices.\n\nExamples\n\nExample 1: Group integer numbers\n\njulia> collect(groupby_numbers_dict([10,20,20,30]))\n3-element Vector{Tuple{Any, Vector{Int64}}}:\n (10, [10])\n (20, [20, 20])\n (30, [30])\n\njulia> collect(groupby_numbers_dict([10,20,-20,30]; keyfunc=abs))\n3-element Vector{Tuple{Any, Vector{Int64}}}:\n (10, [10])\n (20, [20, -20])\n (30, [30])\n\nExample 2: Group floating point numbers\n\njulia> collect(groupby_numbers_dict([ 2e-5, 2e-4, 2e-3, 2e-2 ] .+ 1; rtol=1e-3))\n3-element Vector{Tuple{Any, Vector{Float64}}}:\n (1.00002, [1.00002, 1.0002])\n (1.002, [1.002])\n (1.02, [1.02])\n\njulia> collect(groupby_numbers_dict(\n            [ 1+2e-5, -(1+2e-4), 1+2e-3, -(1+2e-2) ];  \n            keyfunc=abs, rtol=1e-3))\n3-element Vector{Tuple{Any, Vector{Float64}}}:\n (1.00002, [1.00002, -1.0002])\n (1.002, [1.002])\n (1.02, [-1.02])\n\nExample 3: Group noisy vectors with their norm\n\njulia> using LinearAlgebra\njulia> vs1=[ begin \n            v=(i1+(rand()-0.5)*1e-8,i2+(rand()-0.5)*1e-8);\n            (v=v,n=norm(v))\n        end for i1 in -2:2, i2 in -2:2] |> vec;\njulia> vs2=sort(vs1; by=x->x.n);\njulia> [ (k,length(xg)) for (k,xg) in \n            groupby_numbers_dict(vs2; keyfunc=x->x.n, rtol=1e-3) ]\n6-element Vector{Tuple{Float64, Int64}}:\n (4.641593797139748e-11, 1)\n (0.9999999999691114, 4)\n (1.4142135623658871, 4)\n (1.99999999995389, 4)\n (2.236067977448624, 8)\n (2.828427124697913, 4)\n\n\n\n\n\n","category":"function"},{"location":"#See-also","page":"Home","title":"See also","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"IterTools.groupby","category":"page"}]
}
